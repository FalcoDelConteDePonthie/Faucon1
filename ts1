'''Versione con plot di 02/06/2019 notte '''

#This method read csv file row for row and insert value in list
def leggiCsv(nomeFile,separatore):
    file = pd.read_csv(nomeFile,separatore)
    return file.values.tolist()

# This method calculate the distance between datapoint and centroid attribute 
# for attribute (X1_1 - Z1_1)^2 + (X1_2 - Z1_2)^2 
def distance(X,Z):
    dist = 0
    for j in range(0,d):
        dist += pow(X[j] - Z[j],2)
    
    return dist

# This method normalize value of dataset
def normalizzaDati(dati):
    for j in range(0,d):
        max = 0
        min = 1000000000
        for i in range(0,n):
            if dati[i][j] > max:
                max = dati[i][j]
            if dati[i][j] < min:
                min = dati[i][j]

        for i in range(0,n):
            dati[i][j] = (dati[i][j] - min)/(max - min)
    return dati

# This method select random initial centroid from dataset
def calcolaCentroidiRandom(dati):
    centroidi = []
    app = []
    i = 0

    while i < int(k):
        # Estrae il data point
        app = dati[int(int(0) + (random() * (int(n) - int(0))))]
       
        try:
            # Il metodo index restituisce l'indice se lo trova nel vettore altrimenti
            # da eccezione, se da eccezione allora il data point è corretto
            # altrimenti lo ricalcolo
           idx = centroidi.index(app)
        except ValueError:
           # Se non esiste allora incremento i e lo metto in centroidi
           i += 1
           centroidi.append(app)        
    return centroidi   

# This method set avery point to the centroid whit smallest distance by it
def assegnaAlCentroide(A,C,dati):
    for i in range(0,n):
        minima = 999999999999999
        indice = -1
        for j in range(0,k):
            curDist = distance(dati[i],Z[j])
            if curDist < minima:
                minima = curDist
                indice = j
        #print(str(dati[i]) + " - " + str(minima) + " - " + str(j))
        A[i][indice] = 1         
    return A    

# This method update matrix U and identify the minimal distance for every point
def updateU(A,C,D,dati):
    # Loop for alle the row of U
    for i in range(0,n):
        minima = 9999999999999
        indice = -1
        # If the point is classificated outlier i jump it
        if U[i][k] != 1:
            # Loop on all the colum of U
            for j in range(0,k):
                curDist = distance(dati[i],C[j])
                # If the distance calculated is < of previus minim distance i change
                if curDist < minima:
                    minima = curDist
                    indice = j
            # blank the row
            for j in range(0,k):
                A[i][j] = 0
                
            # If the value is > D set colum k value to 1      
            if minima > D:
                A[i][k] = 1  
            # else set colum indice (centroid) value to 1          
            else:
                A[i][indice] = 1               

    return A

def updateZ(A,C,dati):
    centroide = []
    for l in range(0,k):
        somma = np.zeros((1,d))
        cnt = 0
        for i in range(0,n):
            if A[i][l] == 1:
                somma+=dati[i]
                cnt+=1
        # se elementi vuoto?
        somma/=cnt
        
        centroide.append(somma[0])
    return centroide  

# Metodo che calcola la variabile D per determinare quali dei data point sono
# outlier e quali no
def getD(A,C,dati):
    # n a questo punto è il valore aggiornato di dati esclusi gli outlier
    n = np.shape(dati)[0]
    coff = gamma/(n)
    print("coff:"+str(coff))
    clusterDist = np.zeros((n,1))
    somma = 0

    #Ciclo sugli centroidi
    for i in range(0,n):    
        for l in range(0,k):  
            if(A[i][l] == 1):
                app = distance(dati[i],C[l])
                clusterDist[i] = app
                somma += app
    print("SOMMA:"+str(somma))
        #print("__________")        
    # Ritono in uscita il valore della variabile D    
    return coff * somma,clusterDist

def printa(value1,value2):
    print(str(value1) + "  -   " + str(value2))

def contaOutlier(A):
    return np.sum(A, axis=0)[k]

def getP(A,B,D,dati):
    somma = 0
    for i in range(0,n):
        for l in range(0,k):
            #U[i][l] * dist^2 <- la ho in clusterDist e U[i][l] o è 0 o è 1
            if U[i][l] == 1:
                somma += clusterDist[i]
    # Alla fine sommo il numero di outlier 
    somma += outlier*D
    return somma

import numpy as np
import pandas as pd
import pylab as pl
from numpy import linalg as LA
from random import random

#k = numero desiderato di cluster
k=2
sigma = pow(10,-6)
gamma = 5
numeroOutlier = 0
nMax =100
dati = leggiCsv("risultati2.csv",";")

n = np.shape(dati)[0]
d = np.shape(dati)[1]
#dati = normalizzaDati(dati)
clusterDist = np.zeros((n,1))
outlier = 0 

no = 0.1*float(n)
TOT = 0
# Calcolo k centroidi random  
Z = calcolaCentroidiRandom(dati)
Z= [[1.3,2.3], [5.6, 1]]
U = np.zeros((int(n),int(k)+1))

# Assegno i data point al loro centroide aggiornando U
D = 100000000000
S = 0
P = 0
# Assegno ai centroidi i vari punti in base alle distanze
U = assegnaAlCentroide(U,Z,dati)

while 1:
    for i in range(0,n):
        pl.plot(dati[i][0],dati[i][1],'ro')
    pl.show()
    # Aggiorno U classificando i punti di outlier (al primo giro nessuno D = 100000000000)
    U = updateU(U,Z,D,dati)       
    if(S > 0):
        print("________________________________________")
        print(Z)
    # Conto gli outlier e ne tengo il conto per calcolare P
    numeroOutlier = contaOutlier(U)
    print("Numero outlier:"+str(numeroOutlier))
    outlier+=numeroOutlier    

    if(numeroOutlier > 0):
        print("Modifico dati con S:"+str(S))
        Elementi = np.argwhere(U[:, [k]] == 1)
        dati1 = dati.copy()
 
        # Ogni outlier identificato viene salvato 
        for i in Elementi:
            if dati1[int(i[0])] in dati:
                pos = dati.index(dati1[i[0]])
                a = dati.pop(pos)          
                
                
        # Rivalorizzo n e ricreo U assegnando di nuovo i valori ai centroidi (a questo punto 0 outlier presenti)
        n = np.shape(dati)[0]
        U = np.zeros((int(n+1),int(k)+1))
        U = assegnaAlCentroide(U,Z,dati)
    
  

    # Ricalcolo Z facendo la somma delle distanze dei punti dal centroide / il numero di punti ad esso abbinati
    Z = updateZ(U,Z,dati)
    print(Z)
    # Incremento S e memorizzo il valore di P per criterio uscita
    D,clusterDist = getD(U,Z,dati)
    print("D:"+str(D))
    S+=1
    app = P
    P = getP(U,Z,D,dati)
    print(P)
    if abs(P-app) < sigma or S > nMax:
        print("Numero fin Outl:"+str(outlier))
        print(Z)
        print(S)
        print("________________________________________")
        TOT = TOT + outlier
        for i in range(0,n):
            if U[i][0] == 1:
                pl.plot(dati[i][0],dati[i][1],'ro')
            else:
                pl.plot(dati[i][0],dati[i][1],'bo')
        pl.plot(Z[1][0],Z[1][1],'rX')
        pl.plot(Z[0][0],Z[0][1],'bX')
        break
    '''if numeroOutlier > no:
        print("Il numero di outlier supera la soglia massima di outlier accettata")
        break'''
    
print(TOT/100)
