'''Versione con plot di 02/06/2019 notte  x 100 shuttle'''
#This method read csv file row for row and insert value in list
def leggiCsv(nomeFile,separatore):
    file = pd.read_csv(nomeFile,separatore)
    return file.values.tolist()

# This method calculate the distance between datapoint and centroid attribute 
# for attribute (X1_1 - Z1_1)^2 + (X1_2 - Z1_2)^2 
def distance(X,Z):

    dist = 0
    for j in range(0,d):
        dist += pow(X[j] - Z[j],2)

    return dist

# This method normalize value of dataset
def normalizzaDati(dati):
    for j in range(0,d):
       somma = np.sum(dati[:][j])
       media = somma/np.shape(dati)[0]
       dev = np.std(dati[:][j])
       for i in range(0,n):
           dati[i][j] = (dati[i][j] - media)/dev            
    return dati

# This method select random initial centroid from dataset
def calcolaCentroidiRandom(dati):
    centroidi = []
    app = []
    i = 0

    while i < int(k):
        # Estrae il data point
        app = dati[int(int(0) + (random() * (int(n) - int(0))))]
       
        try:
            # Il metodo index restituisce l'indice se lo trova nel vettore altrimenti
            # da eccezione, se da eccezione allora il data point è corretto
            # altrimenti lo ricalcolo
           idx = centroidi.index(app)
        except ValueError:
           # Se non esiste allora incremento i e lo metto in centroidi
           i += 1
           centroidi.append(app)        
    return centroidi   

# This method set avery point to the centroid whit smallest distance by it
def assegnaAlCentroide(A,C,dati):
    for i in range(0,n):
        minima = 999999999999999
        indice = -1
        for j in range(0,k):
            curDist = distance(dati[i],Z[j])
            if curDist < minima:
                minima = curDist
                indice = j
        #print(str(dati[i]) + " - " + str(minima) + " - " + str(j))
        A[i][indice] = 1         
    return A    

# This method update matrix U and identify the minimal distance for every point
def updateU(A,C,D,dati):
    # Loop for alle the row of U
    for i in range(0,n):
        minima = 9999999999999
        indice = -1
        # If the point is classificated outlier i jump it
        if U[i][k] != 1:
            # Loop on all the colum of U
            for j in range(0,k):
                curDist = distance(dati[i],C[j])
                # If the distance calculated is < of previus minim distance i change
                if curDist < minima:
                    minima = curDist
                    indice = j
            # blank the row
            for j in range(0,k):
                A[i][j] = 0
                
            # If the value is > D set colum k value to 1      
            if minima > D:
                A[i][k] = 1  
            # else set colum indice (centroid) value to 1          
            else:
                A[i][indice] = 1               

    return A

def updateZ(A,C,dati):
    centroide = []
    for l in range(0,k):
        somma = np.zeros((1,d))
        cnt = 0
        for i in range(0,n):
            if A[i][l] == 1:
                somma+=dati[i]
                cnt+=1
        
        if cnt != 0:
            somma/=cnt
            centroide.append(somma[0])
        if cnt == 0:
            #il centroide era outlier ed e' stato rimosso quindi non ha punti vicini
            somma = C[l]
            centroide.append(somma)

    return centroide  

# Metodo che calcola la variabile D per determinare quali dei data point sono
# outlier e quali no
def getD(A,C,dati):
    # n a questo punto è il valore aggiornato di dati esclusi gli outlier
    n = np.shape(dati)[0]
    coff = gamma/(n)
    clusterDist = np.zeros((n,1))
    somma = 0
    #Ciclo sugli centroidi
    for i in range(0,n):    
        for l in range(0,k):  
            if(A[i][l] == 1):
                app = distance(dati[i],C[l])
                clusterDist[i] = app
                somma += app
            #print("__________")        
    # Ritono in uscita il valore della variabile D    
    return coff * somma,clusterDist

def printa(value1,value2):
    print(str(value1) + "  -   " + str(value2))

def contaOutlier(A):
    return np.sum(A, axis=0)[k]

def getP(A,B,D,dati):
    somma = 0
    for i in range(0,n):
        for l in range(0,k):
            #U[i][l] * dist^2 <- la ho in clusterDist e U[i][l] o è 0 o è 1
            if U[i][l] == 1:
                somma += clusterDist[i]
    # Alla fine sommo il numero di outlier 
    somma += outlier*D
    return somma

import numpy as np
import pandas as pd
import pylab as pl
from numpy import linalg as LA
from random import random
import sys
num = 1
TOT = 0
for w in range(0,1):
    #k = numero desiderato di cluster
    k=3
    sigma = pow(10,-6)
    gamma = 9
    numeroOutlier = 0
    nMax =100
    dati = leggiCsv("shuttle.csv",";")

    n = np.shape(dati)[0]
    d = np.shape(dati)[1]
    #dati = normalizzaDati(dati)
    clusterDist = np.zeros((n,1))
    outlier = 0 
    
    no = 0.1*float(n)

    # Calcolo k centroidi random  
    Z = calcolaCentroidiRandom(dati)
    # Caso con centroide senza dati vicini
    #Z = [[56, 1, 78, 3, 24, 0, 22, 55, 32], [49, 2, 102, 0, 50, 20, 53, 53, 0], [45, 0, 88, -37, 46, -302, 42, 41, 0]]
    U = np.zeros((int(n),int(k)+1))
    
    # Assegno i data point al loro centroide aggiornando U
    D = 100000000000
    S = 0
    P = 0
    # Assegno ai centroidi i vari punti in base alle distanze
    U = assegnaAlCentroide(U,Z,dati)
    #fout = open('risultatioutlier.csv','w')
    while 1:
        
        # Aggiorno U classificando i punti di outlier (al primo giro nessuno D = 100000000000)
        U = updateU(U,Z,D,dati)       
        # Conto gli outlier e ne tengo il conto per calcolare P
        numeroOutlier = contaOutlier(U)
        outlier+=numeroOutlier    
    
        if(numeroOutlier > 0):
            Elementi = np.argwhere(U[:, [k]] == 1)
            dati1 = dati.copy()
     
            # Ogni outlier identificato viene salvato 
            for i in Elementi:
                if dati1[int(i[0])] in dati:
                    pos = dati.index(dati1[i[0]])
                    s = ""
                    #for p in range(0,d):
                    s += str(dati[pos][0])+","    
                    s += str(10)+"\n"
                    #print(s)
     #               fout.write(s)
                    a = dati.pop(pos)          
                    
                    
            # Rivalorizzo n e ricreo U assegnando di nuovo i valori ai centroidi (a questo punto 0 outlier presenti)
            n = np.shape(dati)[0]
            U = np.zeros((int(n+1),int(k)+1))
            U = assegnaAlCentroide(U,Z,dati)
        
      
    
        # Ricalcolo Z facendo la somma delle distanze dei punti dal centroide / il numero di punti ad esso abbinati
        Z = updateZ(U,Z,dati)
        # Incremento S e memorizzo il valore di P per criterio uscita
        D,clusterDist = getD(U,Z,dati)
        S+=1
        app = P
        P = getP(U,Z,D,dati)
    
        if abs(P-app) < sigma or S > nMax:
            print(num)
            print("Numero fin Outl:"+str(outlier))
            print(Z)
            print(S)
            print("________________________________________")
            TOT = TOT + outlier
            num = num + 1
            break
        if numeroOutlier > no:
            print("Il numero di outlier supera la soglia massima di outlier accettata")
            break
        
print(TOT/100)
